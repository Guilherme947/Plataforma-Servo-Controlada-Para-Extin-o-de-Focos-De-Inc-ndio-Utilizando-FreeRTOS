#include <Arduino_FreeRTOS.h>
#include <semphr.h>
#include <Servo.h>

//  PINOS 
#define PIN_MOTOR_A   2  // Ponte H
#define PIN_MOTOR_B   3  // Ponte H 
#define PIN_BUZZER    4  // Buzzer
#define PIN_LED_R     5  // led vermelho
#define PIN_LED_G     6  // led verde
#define PIN_LED_B     7  // lede azul
#define PIN_SENSOR    8  // Sensor infravermelho
#define PIN_SERVO_1   9  // Servo Sensor
#define PIN_SERVO_2   10 // Pan
#define PIN_SERVO_3   11 // Tilt

// LÓGICA DE ESTADOS
#define LIGADO    LOW
#define DESLIGADO HIGH

//  CONFIGURAÇÕES DO SISTEMA 
#define ANGULO_CENTRO   90     
#define AMPLITUDE       60     
#define TILT_DESCIDA    -38    // Offset mecânico do Tilt 
#define OFFSET_PAN      30     // Offset mecânico no Pan
#define DELAY_VARREDURA 20     
#define ESTADO_COM_FOGO LOW  

// ESTADOS DO SISTEMA 
enum SystemState { ESPERA, BUSCA, ALARME };

volatile SystemState estadoAtual = ESPERA;
volatile int posicaoServo1 = ANGULO_CENTRO;

Servo servo1;
Servo servo2;
Servo servo3; 

SemaphoreHandle_t xMutexPosicao;

// PROTÓTIPOS DAS TASKS
void TaskSensor(void *pvParameters);
void TaskServo1(void *pvParameters);
void TaskAtuadores(void *pvParameters);
void TaskSerial(void *pvParameters);

void setup() {
  Serial.begin(9600);

  // Configuração dos GPIO
  pinMode(PIN_BUZZER, OUTPUT);
  pinMode(PIN_LED_R, OUTPUT);
  pinMode(PIN_LED_G, OUTPUT);
  pinMode(PIN_LED_B, OUTPUT);
  pinMode(PIN_SENSOR, INPUT);
  pinMode(PIN_MOTOR_A, OUTPUT);
  pinMode(PIN_MOTOR_B, OUTPUT);

  // Estado Inicial
  digitalWrite(PIN_BUZZER, DESLIGADO);
  digitalWrite(PIN_LED_R, DESLIGADO);
  digitalWrite(PIN_LED_G, DESLIGADO);
  digitalWrite(PIN_LED_B, DESLIGADO);
  digitalWrite(PIN_MOTOR_A, LOW);
  digitalWrite(PIN_MOTOR_B, LOW);

  servo1.attach(PIN_SERVO_1);
  servo2.attach(PIN_SERVO_2);
  servo3.attach(PIN_SERVO_3); 
  
  // CALIBRAÇÃO APLICADA NO BOOT 
  servo1.write(ANGULO_CENTRO);
  servo2.write(ANGULO_CENTRO + OFFSET_PAN); // Já liga desalinhado de proposito
  servo3.write(ANGULO_CENTRO); 

  xMutexPosicao = xSemaphoreCreateMutex();

  // Tasks 
  xTaskCreate(TaskSensor, "Sens", 100, NULL, 4, NULL);     
  xTaskCreate(TaskAtuadores, "Atua", 100, NULL, 3, NULL); 
  xTaskCreate(TaskServo1, "Serv", 100, NULL, 2, NULL);     
  xTaskCreate(TaskSerial, "Seri", 100, NULL, 1, NULL);     

  Serial.println(F("Sistema de combate iniciado."));
}

void loop() {}

// TASK 1: SENSOR 
void TaskSensor(void *pvParameters) {
  for (;;) {
    if (estadoAtual == BUSCA) {
      if (digitalRead(PIN_SENSOR) == ESTADO_COM_FOGO) {
        estadoAtual = ALARME;
        Serial.println(F("!!! FOGO DETECTADO !!!"));
      }
    }
    vTaskDelay(60 / portTICK_PERIOD_MS); 
  }
}

// TASK 2: ATUADORES 
void TaskAtuadores(void *pvParameters) {
  SystemState estadoAnterior = ESPERA; 
  
  for (;;) {
    switch (estadoAtual) {
      case ESPERA:
        digitalWrite(PIN_LED_G, LIGADO);   
        digitalWrite(PIN_LED_B, DESLIGADO);
        digitalWrite(PIN_LED_R, DESLIGADO);
        digitalWrite(PIN_BUZZER, DESLIGADO);
        digitalWrite(PIN_MOTOR_A, LOW);
        digitalWrite(PIN_MOTOR_B, LOW);
        
        if (!servo2.attached()) servo2.attach(PIN_SERVO_2);
        if (!servo3.attached()) servo3.attach(PIN_SERVO_3);
        
        // CALIBRAÇÃO APLICADA NA ESPERA 
        servo2.write(ANGULO_CENTRO + OFFSET_PAN); 
        servo3.write(ANGULO_CENTRO); 
        break;

      case BUSCA:
        digitalWrite(PIN_LED_G, DESLIGADO);
        digitalWrite(PIN_LED_B, LIGADO);    
        digitalWrite(PIN_LED_R, DESLIGADO);
        digitalWrite(PIN_BUZZER, DESLIGADO);
        digitalWrite(PIN_MOTOR_A, LOW); 
        digitalWrite(PIN_MOTOR_B, LOW);
        
        // Embreagem Digital (corta a vibração do Pan e Tilt na busca)
        if (servo2.attached()) servo2.detach();
        if (servo3.attached()) servo3.detach();
        break;

      case ALARME:
        digitalWrite(PIN_LED_G, DESLIGADO);
        digitalWrite(PIN_LED_B, DESLIGADO);
        digitalWrite(PIN_LED_R, LIGADO);    
        digitalWrite(PIN_BUZZER, LIGADO);   
        
        // 1. LEITURA SEGURA DO ALVO
        int alvoPan = ANGULO_CENTRO; 
        if (xSemaphoreTake(xMutexPosicao, (TickType_t) 10) == pdTRUE) {
          alvoPan = posicaoServo1;
          xSemaphoreGive(xMutexPosicao);
        }

        // 2. RELIGA OS SERVOS
        if (!servo2.attached()) servo2.attach(PIN_SERVO_2);
        if (!servo3.attached()) servo3.attach(PIN_SERVO_3);
        
        // 3. COMANDA OS MOVIMENTOS
        // CALIBRAÇÃO APLICADA NO ANGULO DE ATAQUE 
        servo2.write(alvoPan + OFFSET_PAN); 
        servo3.write(ANGULO_CENTRO - TILT_DESCIDA); 
        
        // 4. ATRASO SEGURO
        if (estadoAnterior != ALARME) {
            vTaskDelay(400 / portTICK_PERIOD_MS); 
        }
        
        // 5. Ventoinha liga após os servos
        digitalWrite(PIN_MOTOR_A, HIGH); 
        digitalWrite(PIN_MOTOR_B, LOW);
        break;
    }
    
    estadoAnterior = estadoAtual;
    vTaskDelay(50 / portTICK_PERIOD_MS);
  }
}

// TASK 3: SERVO 1 (VARREDURA) 
void TaskServo1(void *pvParameters) {
  int pos = ANGULO_CENTRO;
  int direcao = 1;
  int limiteMin = ANGULO_CENTRO - AMPLITUDE;
  int limiteMax = ANGULO_CENTRO + AMPLITUDE;

  for (;;) {
    if (estadoAtual == BUSCA) {
      pos += direcao;
      if (pos >= limiteMax || pos <= limiteMin) direcao = -direcao;
      servo1.write(pos);

      if (xSemaphoreTake(xMutexPosicao, (TickType_t) 10) == pdTRUE) {
        posicaoServo1 = pos;
        xSemaphoreGive(xMutexPosicao);
      }
      vTaskDelay(DELAY_VARREDURA / portTICK_PERIOD_MS);
    } 
    else if (estadoAtual == ESPERA) {
      pos = ANGULO_CENTRO;
      direcao = 1;
      servo1.write(ANGULO_CENTRO);
      if (xSemaphoreTake(xMutexPosicao, (TickType_t) 10) == pdTRUE) {
        posicaoServo1 = ANGULO_CENTRO;
        xSemaphoreGive(xMutexPosicao);
      }
      vTaskDelay(200 / portTICK_PERIOD_MS);
    }
    else {
      vTaskDelay(100 / portTICK_PERIOD_MS);
    }
  }
}

// TASK 4: SERIAL 
void TaskSerial(void *pvParameters) {
  for (;;) {
    if (Serial.available() > 0) {
      char c = Serial.read();
      while(Serial.available() > 0) Serial.read();

      if ((c == 'I' || c == 'i') && estadoAtual == ESPERA) {
        Serial.println(F("Iniciando..."));
        estadoAtual = BUSCA;
      }
      
      else if (c == 'r' || c == 'R') {
        Serial.println(F("Comando de Reset recebido..."));

        if (digitalRead(PIN_SENSOR) == ESTADO_COM_FOGO) {
          Serial.println(F(">> ALERTA: Fogo ainda presente! <<"));
          Serial.println(F(">> Reset BLOQUEADO. Aguardando extincao... <<"));
          
          while (digitalRead(PIN_SENSOR) == ESTADO_COM_FOGO) {
            Serial.print(F("."));
            vTaskDelay(1000 / portTICK_PERIOD_MS); 
          }
          Serial.println(F("\n>> Fogo eliminado! Resetando agora. <<"));
        } 
        
        estadoAtual = ESPERA;
        Serial.println(F("Sistema em espera."));
      }
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}
